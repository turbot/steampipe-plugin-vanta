package vanta

import (
	"context"
	"time"

	"github.com/turbot/steampipe-plugin-sdk/v5/grpc/proto"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin/transform"
	"github.com/turbot/steampipe-plugin-vanta/v2/rest_api/model"
)

//// TABLE DEFINITION

func tableVantaVulnerability(ctx context.Context) *plugin.Table {
	return &plugin.Table{
		Name:        "vanta_vulnerability",
		Description: "Vanta Vulnerability - Security vulnerabilities detected across integrations (GitHub, AWS ECR, GCP ECR, etc.)",
		List: &plugin.ListConfig{
			Hydrate: listVantaVulnerabilities,
			KeyColumns: plugin.KeyColumnSlice{
				{Name: "severity", Require: plugin.Optional},
				{Name: "integration_id", Require: plugin.Optional},
				{Name: "is_fixable", Require: plugin.Optional},
			},
		},
		Get: &plugin.GetConfig{
			Hydrate:    getVantaVulnerability,
			KeyColumns: plugin.SingleColumn("id"),
		},
		Columns: []*plugin.Column{
			// Primary fields
			{Name: "id", Type: proto.ColumnType_STRING, Transform: transform.FromField("ID"), Description: "A unique identifier of the vulnerability."},
			{Name: "name", Type: proto.ColumnType_STRING, Description: "The CVE identifier or vulnerability name."},
			{Name: "description", Type: proto.ColumnType_STRING, Description: "A description of the vulnerability."},
			{Name: "severity", Type: proto.ColumnType_STRING, Description: "The severity level: CRITICAL, HIGH, MEDIUM, or LOW."},
			{Name: "cvss_severity_score", Type: proto.ColumnType_DOUBLE, Transform: transform.FromField("CVSSSeverityScore"), Description: "The CVSS severity score."},

			// SLA and timing fields
			{Name: "remediate_by_date", Type: proto.ColumnType_TIMESTAMP, Description: "The SLA deadline by which the vulnerability should be remediated."},
			{Name: "first_detected_date", Type: proto.ColumnType_TIMESTAMP, Description: "When the vulnerability was first detected by Vanta."},
			{Name: "source_detected_date", Type: proto.ColumnType_TIMESTAMP, Description: "When the vulnerability was first detected by the source scanner."},
			{Name: "last_detected_date", Type: proto.ColumnType_TIMESTAMP, Description: "When the vulnerability was last detected."},

			// Status fields
			{Name: "is_fixable", Type: proto.ColumnType_BOOL, Description: "Whether a fix is available for this vulnerability."},
			{Name: "is_deactivated_indefinitely", Type: proto.ColumnType_BOOL, Transform: transform.FromField("DeactivateMetadata.IsVulnDeactivatedIndefinitely"), Description: "Whether monitoring is deactivated indefinitely."},
			{Name: "deactivated_on_date", Type: proto.ColumnType_TIMESTAMP, Transform: transform.FromField("DeactivateMetadata.DeactivatedOnDate"), Description: "When monitoring was deactivated for this vulnerability."},
			{Name: "deactivated_until_date", Type: proto.ColumnType_TIMESTAMP, Transform: transform.FromField("DeactivateMetadata.DeactivatedUntilDate"), Description: "When the vulnerability will be reactivated (if not indefinite)."},
			{Name: "deactivated_by", Type: proto.ColumnType_STRING, Transform: transform.FromField("DeactivateMetadata.DeactivatedBy"), Description: "Who deactivated monitoring for this vulnerability."},
			{Name: "deactivation_reason", Type: proto.ColumnType_STRING, Transform: transform.FromField("DeactivateMetadata.DeactivationReason"), Description: "The reason for deactivating/ignoring this vulnerability."},
			{Name: "deactivate_metadata", Type: proto.ColumnType_JSON, Transform: transform.FromField("DeactivateMetadata"), Description: "Full deactivation metadata object."},
			{Name: "vulnerability_type", Type: proto.ColumnType_STRING, Description: "The type of vulnerability."},
			{Name: "scanner_score", Type: proto.ColumnType_DOUBLE, Description: "Score from the vulnerability scanner."},

			// Source and asset fields
			{Name: "integration_id", Type: proto.ColumnType_STRING, Transform: transform.FromField("IntegrationID"), Description: "The integration ID (source) where this vulnerability was detected."},
			{Name: "scan_source", Type: proto.ColumnType_STRING, Description: "The scanning tool that detected the vulnerability (e.g., Dependabot, Trivy)."},
			{Name: "target_id", Type: proto.ColumnType_STRING, Transform: transform.FromField("TargetID"), Description: "The target ID of the affected resource."},
			{Name: "vulnerable_asset_id", Type: proto.ColumnType_STRING, Transform: transform.FromField("VulnerableAssetID"), Description: "The ID of the vulnerable asset."},
			{Name: "package_identifier", Type: proto.ColumnType_STRING, Description: "The identifier of the vulnerable package."},

			// External reference
			{Name: "external_url", Type: proto.ColumnType_STRING, Transform: transform.FromField("ExternalURL"), Description: "External URL with more details about this vulnerability."},
			{Name: "related_vulns", Type: proto.ColumnType_JSON, Description: "Related vulnerability identifiers."},
			{Name: "related_urls", Type: proto.ColumnType_JSON, Transform: transform.FromField("RelatedURLs"), Description: "Related URLs for more information."},

			// Computed columns for reporting
			{Name: "is_overdue", Type: proto.ColumnType_BOOL, Transform: transform.From(isVulnOverdue), Description: "True if the vulnerability is past its SLA deadline."},
			{Name: "days_until_due", Type: proto.ColumnType_INT, Transform: transform.From(daysUntilDue), Description: "Number of days until (positive) or past (negative) the SLA deadline."},
		},
	}
}

//// LIST FUNCTION

func listVantaVulnerabilities(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	// Create REST client
	client, err := getClient(ctx, d)
	if err != nil {
		plugin.Logger(ctx).Error("vanta_vulnerability.listVantaVulnerabilities", "connection_error", err)
		return nil, err
	}

	maxLimit := int32(100)
	if d.QueryContext.Limit != nil {
		limit := int32(*d.QueryContext.Limit)
		if limit < maxLimit {
			maxLimit = limit
		}
	}

	options := &model.ListVulnerabilitiesOptions{
		Limit:  int(maxLimit),
		Cursor: "",
	}

	// Apply optional filters from key columns
	if d.EqualsQualString("severity") != "" {
		options.Severity = d.EqualsQualString("severity")
	}
	if d.EqualsQualString("integration_id") != "" {
		options.IntegrationID = d.EqualsQualString("integration_id")
	}
	if d.EqualsQuals["is_fixable"] != nil {
		isFixable := d.EqualsQuals["is_fixable"].GetBoolValue()
		options.IsFixAvailable = &isFixable
	}

	for {
		result, err := client.ListVulnerabilities(ctx, options)
		if err != nil {
			plugin.Logger(ctx).Error("vanta_vulnerability.listVantaVulnerabilities", "api_error", err)
			return nil, err
		}

		for _, vuln := range result.Results.Data {
			d.StreamListItem(ctx, vuln)

			if d.RowsRemaining(ctx) == 0 {
				return nil, nil
			}
		}

		if !result.Results.PageInfo.HasNextPage {
			break
		}

		options.Cursor = result.Results.PageInfo.EndCursor
	}

	return nil, nil
}

//// GET FUNCTION

func getVantaVulnerability(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	id := d.EqualsQualString("id")
	if id == "" {
		return nil, nil
	}

	client, err := getClient(ctx, d)
	if err != nil {
		plugin.Logger(ctx).Error("vanta_vulnerability.getVantaVulnerability", "connection_error", err)
		return nil, err
	}

	vuln, err := client.GetVulnerabilityByID(ctx, id)
	if err != nil {
		plugin.Logger(ctx).Error("vanta_vulnerability.getVantaVulnerability", "api_error", err)
		return nil, err
	}

	if vuln == nil {
		return nil, nil
	}

	return vuln, nil
}

//// TRANSFORM FUNCTIONS

// isVulnOverdue checks if the vulnerability is past its SLA deadline
func isVulnOverdue(ctx context.Context, d *transform.TransformData) (interface{}, error) {
	item := d.HydrateItem
	vuln, ok := item.(*model.Vulnerability)
	if !ok {
		return false, nil
	}

	if vuln.RemediateByDate == nil {
		return false, nil
	}

	return time.Now().After(*vuln.RemediateByDate), nil
}

// daysUntilDue calculates days until or past the SLA deadline
func daysUntilDue(ctx context.Context, d *transform.TransformData) (interface{}, error) {
	item := d.HydrateItem
	vuln, ok := item.(*model.Vulnerability)
	if !ok {
		return nil, nil
	}

	if vuln.RemediateByDate == nil {
		return nil, nil
	}

	duration := time.Until(*vuln.RemediateByDate)
	days := int(duration.Hours() / 24)
	return days, nil
}

