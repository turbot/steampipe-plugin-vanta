package rest_api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"

	"github.com/turbot/steampipe-plugin-vanta/v2/rest_api/model"
)

// ListVulnerabilities retrieves a paginated list of vulnerabilities from Vanta
func (c *RestClient) ListVulnerabilities(ctx context.Context, options *model.ListVulnerabilitiesOptions) (*model.ListVulnerabilitiesOutput, error) {
	// Build URL with query parameters
	params := url.Values{}

	if options != nil {
		if options.Limit > 0 {
			params.Set("pageSize", fmt.Sprintf("%d", options.Limit))
		}
		if options.Cursor != "" {
			params.Set("pageCursor", options.Cursor)
		}
		if options.Severity != "" {
			params.Set("severity", options.Severity)
		}
		if options.IsFixAvailable != nil {
			params.Set("isFixAvailable", fmt.Sprintf("%t", *options.IsFixAvailable))
		}
		if options.IsDeactivated != nil {
			params.Set("isDeactivated", fmt.Sprintf("%t", *options.IsDeactivated))
		}
		if options.IntegrationID != "" {
			params.Set("integrationId", options.IntegrationID)
		}
		if options.VulnerableAssetID != "" {
			params.Set("vulnerableAssetId", options.VulnerableAssetID)
		}
		if options.SLADeadlineBeforeDate != nil {
			params.Set("slaDeadlineBeforeDate", options.SLADeadlineBeforeDate.Format("2006-01-02T15:04:05.000Z"))
		}
		if options.SLADeadlineAfterDate != nil {
			params.Set("slaDeadlineAfterDate", options.SLADeadlineAfterDate.Format("2006-01-02T15:04:05.000Z"))
		}
		if options.IncludeVulnerabilitiesWithoutSLAs != nil {
			params.Set("includeVulnerabilitiesWithoutSlas", fmt.Sprintf("%t", *options.IncludeVulnerabilitiesWithoutSLAs))
		}
	}

	resp, err := c.makeRequest(ctx, "GET", "/v1/vulnerabilities", params)
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}

	respBodyBytes, err := c.readResponseBody(resp)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var result *model.ListVulnerabilitiesOutput
	if err = json.Unmarshal(respBodyBytes, &result); err != nil {
		return nil, fmt.Errorf("failed to JSON-decode response body: %w", err)
	}

	return result, nil
}

// GetVulnerabilityByID retrieves a specific vulnerability by its ID
func (c *RestClient) GetVulnerabilityByID(ctx context.Context, id string) (*model.Vulnerability, error) {
	if id == "" {
		return nil, fmt.Errorf("vulnerability ID cannot be empty")
	}

	resp, err := c.makeRequest(ctx, "GET", fmt.Sprintf("/v1/vulnerabilities/%s", id), nil)
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}

	respBodyBytes, err := c.readResponseBody(resp)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var vulnerability *model.Vulnerability
	if err = json.Unmarshal(respBodyBytes, &vulnerability); err != nil {
		return nil, fmt.Errorf("failed to JSON-decode response body: %w", err)
	}

	return vulnerability, nil
}
